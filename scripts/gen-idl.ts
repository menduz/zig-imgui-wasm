
export enum IdlType {
  VOID,
  F32,
  F64,
  U8,
  STRING,
  U32,
  I32,
  I64,
  U64,
  F32_PTR,
  U8_PTR,
  NULL_STRING,
  BOOLEAN,
  ANYPTR,

  GLenum,
  GLint,
  GLsizei,
  GLbitfield,
  GLdouble,
  GLuint,
  GLint_ptr,
  GLboolean,
  GLubyte,
  GLfloat,
  GLvoid
}

export type NamedArgument = { name: string, type: IdlType }

export type Signature = {
  name: string
  returnType: IdlType
  arguments: NamedArgument[]
}

export function genTypescriptTypes(modules: Record<string, Signature[]>) {
  const parts = Object.entries(modules).map(([moduleName, signatures]) => {
    return `
  ${moduleName}: {
    ${signatures.map($ => toTypescriptSignature(moduleName, $)).join('\n    ')}
  }`
  })

  return `
// THIS FILE IS AUTOGENERATED USING "make idl"

export type ImguiWasmImports = {${parts.join('')}\n}`
}


export function genZigTypes(modules: Record<string, Signature[]>) {
  const parts = Object.entries(modules).map(([moduleName, signatures]) => {
    return signatures.map($ => toZigExtern(moduleName, $)).join('\n')
  })

  return `
// THIS FILE IS AUTOGENERATED USING "make idl"

${parts.join('\n\n')}

`
}

function toTypescriptSignature(moduleName: string, signature: Signature) {
  return `// ${toZigExtern(moduleName, signature)}
    ${signature.name}(${signature.arguments.map(_ => `${_.name}: ${toTypescriptType(_.type)}`).join(', ')}): ${toTypescriptType(signature.returnType)}`
}

function toZigExtern(moduleName: string, signature: Signature) {
  return `pub extern "${moduleName}" fn ${signature.name}(${signature.arguments.map(_ => `${_.name}: ${toZigType(_.type)}`).join(', ')}) ${toZigType(signature.returnType)};`
}

function toZigType(type: IdlType) {
  switch (type) {
    case IdlType.F32: return 'f32'
    case IdlType.F64: return 'f64'
    case IdlType.ANYPTR: return '?*const anyopaque'
    case IdlType.GLint_ptr: return '?*const i32'
    case IdlType.U8: return 'u8'
    case IdlType.U8_PTR: return '*u8'
    case IdlType.F32_PTR: return '[*c]const f32'
    case IdlType.NULL_STRING: return '?*const u8'
    case IdlType.STRING: return '*const u8'
    case IdlType.VOID: return 'void'
    case IdlType.U32: return 'u32'
    case IdlType.U64: return 'u64'
    case IdlType.BOOLEAN: return 'c_uint'
    case IdlType.I32: return 'i32'
    case IdlType.I64: return 'i64'
    case IdlType.GLenum: return 'u32'
    case IdlType.GLint: return 'i32'
    case IdlType.GLsizei: return 'i32'
    case IdlType.GLuint: return 'u32'
  }
  throw new Error('unknown zig type for ' + type + ' ' + IdlType[type])
}

function toTypescriptType(type: IdlType) {
  switch (type) {
    case IdlType.VOID: return 'void'
  }
  return 'number'
}



function canonicalToIdlType(type: string): IdlType {
  switch (type.trim()) {
    case 'void': return IdlType.VOID
    case 'u32': return IdlType.U32
    case 'usize': return IdlType.U32
    case 'i32': return IdlType.I32
    case 'f32': return IdlType.F32
    case 'u8': return IdlType.U8
    case 'u8_ptr': return IdlType.U8_PTR
    case 'f32_ptr': return IdlType.F32_PTR
    case 'string': return IdlType.STRING
    case '?string': return IdlType.NULL_STRING
    case 'anyptr': return IdlType.ANYPTR
    case 'GLenum': return IdlType.GLenum
    case 'GLint': return IdlType.GLint
    case 'GLsizei': return IdlType.GLsizei
    case 'GLuint': return IdlType.GLuint
    case 'GLint_ptr': return IdlType.GLint_ptr
    case 'boolean': return IdlType.BOOLEAN
  }
  throw new Error(`unknown type ${type}`)
}

export function parseSignature(sig: string): Signature {
  const name = sig.match(/^([^(]+)+/)![1]
  if (!name) throw new Error('invalid name in ' + sig)
  const args$ = sig.match(/\((.*)\)/)![1]
  if (typeof args$ !== 'string') throw new Error('invalid args in ' + sig)
  let args: string[][] = []
  if (args$.trim()) {
    args = args$.split(',').map($ => $.split(':'))
    if (args.some($ => $.length !== 2)) throw new Error('invalid args (inner) in ' + sig)
  }
  const ret = sig.match(/\)\s*(.*)/)![1]
  if (!ret) throw new Error('invalid return type in ' + sig)

  return {
    arguments: args.map(([name, type]) => ({ name: name.trim(), type: canonicalToIdlType(type) })),
    name: name.trim(),
    returnType: canonicalToIdlType(ret)
  }
}
